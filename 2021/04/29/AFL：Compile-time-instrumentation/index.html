<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>AFL:Compile-time Instrumentation | Lxumei</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="这篇文章主要从源码角度剖析AFL的编译时插桩。AFL的编译时插桩主要有以下几个目的：实现forkserver，使execve()只需要调用一次；设置共享内存，使得AFL进程可以和target进程共享边覆盖信息；动态反馈目标程序的边覆盖信息。本文结下来将从源码角度对以上部分的实现进行解析。 forkserver主要是为了避免频繁调用execve()引起的开销。forkserver的实现方式是：（1）">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL:Compile-time Instrumentation">
<meta property="og:url" content="https://lxumei.github.io/2021/04/29/AFL%EF%BC%9ACompile-time-instrumentation/index.html">
<meta property="og:site_name" content="Lxumei">
<meta property="og:description" content="这篇文章主要从源码角度剖析AFL的编译时插桩。AFL的编译时插桩主要有以下几个目的：实现forkserver，使execve()只需要调用一次；设置共享内存，使得AFL进程可以和target进程共享边覆盖信息；动态反馈目标程序的边覆盖信息。本文结下来将从源码角度对以上部分的实现进行解析。 forkserver主要是为了避免频繁调用execve()引起的开销。forkserver的实现方式是：（1）">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-29T13:22:29.416Z">
<meta property="article:modified_time" content="2021-05-04T05:45:01.583Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Lxumei" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lxumei</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lxumei.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-AFL：Compile-time-instrumentation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/29/AFL%EF%BC%9ACompile-time-instrumentation/" class="article-date">
  <time class="dt-published" datetime="2021-04-29T13:22:29.416Z" itemprop="datePublished">2021-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      AFL:Compile-time Instrumentation
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这篇文章主要从源码角度剖析AFL的编译时插桩。AFL的编译时插桩主要有以下几个目的：实现forkserver，使execve()只需要调用一次；设置共享内存，使得AFL进程可以和target进程共享边覆盖信息；动态反馈目标程序的边覆盖信息。本文结下来将从源码角度对以上部分的实现进行解析。</p>
<p>forkserver主要是为了避免频繁调用execve()引起的开销。forkserver的实现方式是：<br>（1）通过编译时插桩，在目标程序的开头插入一些桩代码，得到了一个插桩后的二进制文件。AFL真正fuzz的，实际是这个插桩后的二进制文件；<br>（2）AFL开始执行后，首先会创建一个forkserver进程。forkserver进程会通过execve()执行插桩后的二进制文件。forkserver进程首先执行的是（1）中插入的桩代码，桩代码一开始会阻塞，等待AFL发送“执行”的命令。当AFL通过管道发送“执行”命令后，forkserver就会通过fork()创建一个子进程。在子进程内，桩代码会将控制权限转移给桩代码之后的代码，假设是main()，那么子进程就会从main()开始执行；而此是forkserver进程会通过管道将子进程的ID发送给AFL，并等待子进程的执行结束。</p>
<h2 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h2><p>afl-as.c是真正对目标程序进行插桩的文件，其基本思想是，遍历目标程序对应的汇编文件的每一行代码，然后判断其是不是一个基本块的开始，如果是的话，就在这行代码之前进行插桩，以32位为例子，会插入如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 &#x3D;</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;&#x2F;* --- AFL TRAMPOLINE (32-BIT) --- *&#x2F;\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi, 0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx, 4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx, 8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl 8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl 4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl 0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;&#x2F;* --- END --- *&#x2F;\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>这段的代码的主要作用是：</p>
<ol>
<li>将edi等寄存器保存到栈上。第8-12行代码将寄存器edi、edx、ecx、eax保存到栈上。</li>
<li>将寄存器ecx的值设置为fprintf()中传入的<code>R(MAP_SIZE)</code>，第13行中<code>%08x</code>对应的值是<code>R(MAP_SIZE)</code>，<code>R(MAP_SIZE)</code>的作用是生成一个0～MAP_SIZE间的随机数。</li>
<li>调用<code>__afl_maybe_log</code>。</li>
<li>恢复edi等寄存器，对应于代码的15行到第19行。</li>
</ol>
<p>接下来看<font color=red>__alf_maybe_log</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_maybe_log:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  lahf\n&quot;</span><br><span class="line">&quot;  seto %al\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Check if SHM region is already mapped. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  movl  __afl_area_ptr, %edx\n&quot; ;__afl_area_ptr指向共享内存</span><br><span class="line">&quot;  testl %edx, %edx\n&quot;</span><br><span class="line">&quot;  je    __afl_setup\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>在<code>__afl_maybe_log</code>里面，会首先判断共享内存是否映射完成（我觉得这里也是在判断forkserver进程是否启动；__afl_area_ptr指向共享内存，在后面会解释），如果未完成映射，会执行<code>__afl_setup</code>；如果映射完成，那么会执行 <code>__afl_store</code>。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存主要用于AFL进程和target进程通信。target进程可以通过写入共享内存更新target的覆盖信息；而AFL进程可以在target执行完毕后，通过访问共享内存获取target的覆盖信息。</p>
<p>”共享内存“是Linux下进程间的一种通信方式，两个进程将各自的一段虚拟内存空间映射到同一块物理地址上，然后这两个进程就可以通过操作这块物理地址进行通信。Linux下共享内存的具体实现方式：<br>（1）使用shmget()函数创建共享内存，并返回一个共享内存标识符shm_id 。shmget()原型为<code> int shmget(key_t key, size_t size, int shmflg);</code>。但是创建完共享内存时，它还不能被任何进程访问<br>（2）shmat()函数的作用就是根据shm_id，将进程attach到共享内存上，即将进程虚拟地址空间中的一段内存映射到共享内存。shmat()的函数原型为<code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code>。</p>
<h3 id="AFL进程中共享内存设置"><a href="#AFL进程中共享内存设置" class="headerlink" title="AFL进程中共享内存设置"></a>AFL进程中共享内存设置</h3><p>AFL通过共享内存获取一个测试用例对目标程序的边覆盖信息。AFL开启后，会通过<code>setup_shm()</code>设置共享内存。<br>（1）首先通过shmget()创建大小为MAP_SIZE的共享内存：<code>shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); </code><br>（2）将共享内存标识符存储到环境变量，forkserver进程和target进程就可以通过环境变量访问共享内存标识符：<code>shm_str = alloc_printf(&quot;%d&quot;, shm_id);  setenv(SHM_ENV_VAR, shm_str, 1);</code><br>（3）AFL使用变量 <font color = 'red'>trace_bits</font> attach到共享内存：<code>trace_bits = shmat(shm_id, NULL, 0);</code>，然后AFL就可以通过trace_bits访问共享内存。在每次执行target之前，AFL会将<font color = 'red'>trace_bits</font> 清零。</p>
<h3 id="target进程共享内存设置"><a href="#target进程共享内存设置" class="headerlink" title="target进程共享内存设置"></a>target进程共享内存设置</h3><p>在<font color=red>__alf_maybe_log</font>中，如果共享内存未完成映射，就会执行<code>je __afl_setup</code>设置共享内存。<code>__afl_setup</code>的作用是获取AFL进程设置的共享内存标识符，并在target进程内attach上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_setup:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Do not retry setup if we had previous failures. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpb $0, __afl_setup_failure\n&quot;</span><br><span class="line">&quot;  jne  __afl_return\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Map SHM, jumping to __afl_setup_abort if something goes wrong.\n&quot;</span><br><span class="line">&quot;     We do not save FPU&#x2F;MMX&#x2F;SSE registers here, but hopefully, nobody\n&quot;</span><br><span class="line">&quot;     will notice this early in the game. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl %eax\n&quot; ;将eax寄存器压栈</span><br><span class="line">&quot;  pushl %ecx\n&quot; ;将ecx寄存器压栈</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $.AFL_SHM_ENV\n&quot; ;压入getenv的参数</span><br><span class="line">&quot;  call  getenv\n&quot; ;getenv(AFL_SHM_ENV)，返回值存储在eax寄存器</span><br><span class="line">&quot;  addl  $4, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  testl %eax, %eax\n&quot; ;判断环境变量AFL_SHM_ENV是否存在</span><br><span class="line">&quot;  je    __afl_setup_abort\n&quot; ;环境变量AFL_SHM_ENV不存在，共享内存映射失败</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl %eax\n&quot; ; eax &#x3D; getenv(AFL_SHM_ENV)</span><br><span class="line">&quot;  call  atoi\n&quot; ; eax &#x3D; atoi(getenv(AFL_SHM_ENV))</span><br><span class="line">&quot;  addl  $4, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $0          &#x2F;* shmat flags    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $0          &#x2F;* requested addr *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl %eax        &#x2F;* SHM ID         *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  shmat\n&quot; ; eax &#x3D; shmat(shm_id, 0, 0)</span><br><span class="line">&quot;  addl  $12, %esp\n&quot; </span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl $-1, %eax\n&quot;</span><br><span class="line">&quot;  je   __afl_setup_abort\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Store the address of the SHM region. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  movl %eax, __afl_area_ptr\n&quot;</span><br><span class="line">&quot;  movl %eax, %edx\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  popl %ecx\n&quot;</span><br><span class="line">&quot;  popl %eax\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>分析上述桩代码，其实主要作了以下几件事：<br>（1）通过环境变量获取共享内存标识符shm_id：getenv(AFL_SHM_ENV)<br>（2）通过shmat()函数，将共享内存地址存储到__afl_area_ptr：___afl_area_ptr = shmat(shm_id, 0, 0)</p>
<h2 id="forkserver"><a href="#forkserver" class="headerlink" title="forkserver"></a>forkserver</h2><p>forkserver主要是为了避免频繁调用execve()引起的开销。在完成了共享内存映射后，就会进入forkserver，执行<code>__afl_forkserver</code>。</p>
<p>首先，看一下forkserver进程是如何创建的。AFL通过<font color = 'red'>init_forkserver()</font>进行forkserver相关的初始化工作：</p>
<ol>
<li><p>创建状态管道和命令管道，用于AFL和forkserver进程之间的通信：int st_pipe[2], ctl_pipe[2]；</p>
<p>AFL通过写命令管道向forkserver发送命令，forkserver通过读命令管道接收AFL的发送的命令；forkserver通过写状态管道向AFL发送信息，AFL通过读状态管道接收forkserver发送的信息。</p>
</li>
<li><p>创建forkserver进程：forksrv_pid = fork(); 在forkserver进程中：</p>
<p>首先对状态管道和命令管道进行重定位：dup2(ctl_pipe[0], FORKSRV_FD) 和 dup2(st_pipe[1], FORKSRV_FD <strong>+</strong> 1）。</p>
<p>之后，forkserver进程执行execv(target_path, argv); forkserver调用了execv之后，会在target第一个基本块处执行插入的桩代码，调用<code>__afl_maybe_log</code>，然后跳到<code>__afl_setup</code>设置共享内存。共享内存设置完毕后，就进入了<code>__afl_forkserver</code>。</p>
</li>
</ol>
<p>接下来看一下<code>__afl_forkserver</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_forkserver:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Enter the fork server mode to avoid the overhead of execve() calls. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl %eax\n&quot;</span><br><span class="line">&quot;  pushl %ecx\n&quot;</span><br><span class="line">&quot;  pushl %edx\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Phone home and tell the parent that we&#39;re OK. (Note that signals with\n&quot;</span><br><span class="line">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span><br><span class="line">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot; </span><br><span class="line">&quot;     the parent doesn&#39;t want to use the fork server. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $4          &#x2F;* length    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_temp &#x2F;* data      *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;  &#x2F;* file desc *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  write\n&quot; ; write(STRINGIFY((FORKSRV_FD + 1)), __afl_temp, 4)</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl  $4, %eax\n&quot;</span><br><span class="line">&quot;  jne   __afl_fork_resume\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>forkserver首先会向状态管道写端（即 FORKSRV_FD + 1）写入4字节的内容，告诉AFL“<font color = 'red'>我准备好fork了</font>”，而AFL进程也会通过读状态管道，判断forkserver进程是否创建成功：rlen = read(fsrv_st_fd, &amp;status, 4)。</p>
<p>forkserver创建成功后，就会进入<code>__afl_fork_wait_loop</code> ，forkserver会阻塞，直到读取命令管道成功：read(STRINGIFY(FORKSRV_FD), __afl_tmp, 4)，然后forkserver判断AFL是否发送了“<font color = 'red'>fork一个子进程</font>“的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_fork_wait_loop:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Wait for parent by reading from the pipe. Abort if read fails. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $4          &#x2F;* length    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_temp &#x2F;* data      *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;        &#x2F;* file desc *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  read\n&quot; ; read(STRINGIFY(FORKSRV_FD), __afl_tmp, 4)</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl  $4, %eax\n&quot;</span><br><span class="line">&quot;  jne   __afl_die\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span><br><span class="line">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span><br><span class="line">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span><br><span class="line">&quot;     abort(), raise(), and a bunch of other things :-( *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>当forkserver收到AFL创建一个子进程的命令后，就会调用fork()创建target进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;  call fork\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl $0, %eax\n&quot;</span><br><span class="line">&quot;  jl   __afl_die\n&quot;</span><br><span class="line">&quot;  je   __afl_fork_resume\n&quot;</span><br></pre></td></tr></table></figure>

<p>在target进程里面，会跳到<code>__afl_fork_resume</code>执行，关闭文件描述符，恢复target的正常执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_fork_resume:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* In child process: close fds, resume execution. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;\n&quot;</span><br><span class="line">&quot;  call  close\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;\n&quot;</span><br><span class="line">&quot;  call  close\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  addl  $8, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  popl %edx\n&quot;</span><br><span class="line">&quot;  popl %ecx\n&quot;</span><br><span class="line">&quot;  popl %eax\n&quot;</span><br><span class="line">&quot;  jmp  __afl_store\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>在forkserver进程里面，也就是在父进程里面，会将target进程的PID写入状态管道，然后等待target进程结束。target进程结束后，forkserver会再次向AFL说“<font color = 'red'>我准备好fork了</font>”，并继续执行<code> __afl_fork_wait_loop</code>，等待AFL发送“<font color = 'red'>fork一个子进程</font>“的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&quot;  &#x2F;* In parent process: write PID to pipe, then wait for child. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  movl  %eax, __afl_fork_pid\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $4              &#x2F;* length    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_fork_pid &#x2F;* data      *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;      &#x2F;* file desc *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  write\n&quot;</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $0             &#x2F;* no flags  *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_temp    &#x2F;* status    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl __afl_fork_pid &#x2F;* PID       *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  waitpid\n&quot;</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl  $0, %eax\n&quot;</span><br><span class="line">&quot;  jle   __afl_die\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Relay wait status to pipe, then loop back. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $4          &#x2F;* length    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_temp &#x2F;* data      *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;  &#x2F;* file desc *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  write\n&quot;</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  jmp __afl_fork_wait_loop\n&quot;</span><br></pre></td></tr></table></figure>

<h2 id="边覆盖记录"><a href="#边覆盖记录" class="headerlink" title="边覆盖记录"></a>边覆盖记录</h2><p>在<font color=red>__alf_maybe_log</font>中，如果共享内存完成了映射，就会执行<code>__afl_store</code>，在共享内存中更新边覆盖情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  &quot;__afl_store:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  &#x2F;* Calculate and store hit for the code location specified in ecx. There\n&quot;</span><br><span class="line">  &quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span><br><span class="line">  &quot;     and we use it on 64-bit systems; but it&#39;s slower for 32-bit ones. *&#x2F;\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">#ifndef COVERAGE_ONLY</span><br><span class="line">  &quot;  movl __afl_prev_loc, %edi\n&quot; ;将__alf_prev_loc的值存储到寄存器edi</span><br><span class="line">  &quot;  xorl %ecx, %edi\n&quot;	 ;将“__alf_prev_loc 异或 ecx”的值存储到edi寄存器中，相当于将边ID存储到了寄存器edi中</span><br><span class="line">  &quot;  shrl $1, %ecx\n&quot; ;将ecx的值右移1位，然后存储至ecx寄存器中</span><br><span class="line">  &quot;  movl %ecx, __afl_prev_loc\n&quot; ;将ecx寄存器的值存储到__afl_prev_loc中</span><br><span class="line">#else</span><br><span class="line">  &quot;  movl %ecx, %edi\n&quot;</span><br><span class="line">#endif &#x2F;* ^!COVERAGE_ONLY *&#x2F;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">#ifdef SKIP_COUNTS</span><br><span class="line">  &quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span><br><span class="line">#else</span><br><span class="line">  &quot;  incb (%edx, %edi, 1)\n&quot;</span><br><span class="line">#endif &#x2F;* ^SKIP_COUNTS *&#x2F;</span><br><span class="line">  &quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p><code>__afl_store</code>的作用是计算前一个基本块（pre_location）到当前基本块（cur_location）这条边的ID，然后统计其出现次数。具体地，AFL使用（pre_location &gt;&gt; 1) xor (cur_locatino) 的方式记录一条边；使用共享内存（存储在寄存器edx中）统计边的出现次数。在上述汇编代码中：<br>（1）ecx存储的是<code>R(MAP_SIZE)</code>得到的值，也就是存储着为当前这个基本块分配的ID，即伪代码中的cur_location；<br>（2）<code>__afl_prev_loc</code>表示<font color = 'red'>上一个基本块的ID&gt;&gt;1</font>；<br>（3）edx存储的是共享内存的地址。<br>（4）<code>incb (%edx, %edi, 1)</code>这条指令就在共享内存（edx）中，将这条边（edi）的出现次数+1。</p>
<p>__afl_store之后是<code>__afl_return:\n</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_return:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  addb $127, %al\n&quot;</span><br><span class="line">&quot;  sahf\n&quot;</span><br><span class="line">&quot;  ret\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://lxumei.github.io/2021/04/29/AFL%EF%BC%9ACompile-time-instrumentation/" data-id="cko9m2zz20001gdfq6jz4az13" data-title="AFL:Compile-time Instrumentation" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/04/28/AFL%E6%A6%82%E8%BF%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">AFL概述</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/29/AFL%EF%BC%9ACompile-time-instrumentation/">AFL:Compile-time Instrumentation</a>
          </li>
        
          <li>
            <a href="/2021/04/28/AFL%E6%A6%82%E8%BF%B0/">AFL概述</a>
          </li>
        
          <li>
            <a href="/2021/04/27/Fuzz%E6%A6%82%E8%BF%B0/">Fuzzing概述</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>