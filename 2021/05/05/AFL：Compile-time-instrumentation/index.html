<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"lxumei.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="这篇文章主要从源码角度剖析AFL的编译时插桩。AFL的编译时插桩主要有以下几个目的：实现forkserver，使execve()只需要调用一次；设置共享内存，使得AFL进程可以和target进程共享边覆盖信息；动态反馈目标程序的边覆盖信息。本文将从源码角度对以上部分的实现进行解析。">
<meta property="og:type" content="article">
<meta property="og:title" content="AFL:Compile-time Instrumentation">
<meta property="og:url" content="https://lxumei.github.io/2021/05/05/AFL%EF%BC%9ACompile-time-instrumentation/index.html">
<meta property="og:site_name" content="Lxumei&#39;s Blog">
<meta property="og:description" content="这篇文章主要从源码角度剖析AFL的编译时插桩。AFL的编译时插桩主要有以下几个目的：实现forkserver，使execve()只需要调用一次；设置共享内存，使得AFL进程可以和target进程共享边覆盖信息；动态反馈目标程序的边覆盖信息。本文将从源码角度对以上部分的实现进行解析。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lxumei.github.io/images/image-20210504232350375.png">
<meta property="article:published_time" content="2021-05-05T03:05:25.060Z">
<meta property="article:modified_time" content="2021-05-05T03:05:25.060Z">
<meta property="article:author" content="Lxumei">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lxumei.github.io/images/image-20210504232350375.png">

<link rel="canonical" href="https://lxumei.github.io/2021/05/05/AFL%EF%BC%9ACompile-time-instrumentation/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>AFL:Compile-time Instrumentation | Lxumei's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lxumei's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://lxumei.github.io/2021/05/05/AFL%EF%BC%9ACompile-time-instrumentation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lxumei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lxumei's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          AFL:Compile-time Instrumentation
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-05 11:05:25" itemprop="dateCreated datePublished" datetime="2021-05-05T11:05:25+08:00">2021-05-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这篇文章主要从源码角度剖析AFL的编译时插桩。AFL的编译时插桩主要有以下几个目的：实现forkserver，使execve()只需要调用一次；设置共享内存，使得AFL进程可以和target进程共享边覆盖信息；动态反馈目标程序的边覆盖信息。本文将从源码角度对以上部分的实现进行解析。<span id="more"></span></p>
<h2 id="插桩"><a href="#插桩" class="headerlink" title="插桩"></a>插桩</h2><p>afl-as.c是真正对目标程序进行插桩的文件，其基本思想是，遍历目标程序对应的汇编文件的每一行代码，然后判断其是不是一个基本块的开始，如果是的话，就在这行代码之前进行插桩，以32位为例子，会插入如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static const u8* trampoline_fmt_32 &#x3D;</span><br><span class="line"></span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;&#x2F;* --- AFL TRAMPOLINE (32-BIT) --- *&#x2F;\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;.align 4\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;leal -16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;movl %%edi, 0(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%edx, 4(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%ecx, 8(%%esp)\n&quot;</span><br><span class="line">  &quot;movl %%eax, 12(%%esp)\n&quot;</span><br><span class="line">  &quot;movl $0x%08x, %%ecx\n&quot;</span><br><span class="line">  &quot;call __afl_maybe_log\n&quot;</span><br><span class="line">  &quot;movl 12(%%esp), %%eax\n&quot;</span><br><span class="line">  &quot;movl 8(%%esp), %%ecx\n&quot;</span><br><span class="line">  &quot;movl 4(%%esp), %%edx\n&quot;</span><br><span class="line">  &quot;movl 0(%%esp), %%edi\n&quot;</span><br><span class="line">  &quot;leal 16(%%esp), %%esp\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;&#x2F;* --- END --- *&#x2F;\n&quot;</span><br><span class="line">  &quot;\n&quot;;</span><br></pre></td></tr></table></figure>
<p>这段的代码的主要作用是：</p>
<ol>
<li>将edi等寄存器保存到栈上。第8-12行代码将寄存器edi、edx、ecx、eax保存到栈上。</li>
<li>将寄存器ecx的值设置为fprintf()中传入的<code>R(MAP_SIZE)</code>，第13行中<code>%08x</code>对应的值是<code>R(MAP_SIZE)</code>，<code>R(MAP_SIZE)</code>的作用是生成一个0～MAP_SIZE间的随机数。</li>
<li>调用<code>__afl_maybe_log</code>。</li>
<li>恢复edi等寄存器，对应于代码的15行到第19行。</li>
</ol>
<p>接下来看<font color=red>__alf_maybe_log</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_maybe_log:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  lahf\n&quot;</span><br><span class="line">&quot;  seto %al\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Check if SHM region is already mapped. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  movl  __afl_area_ptr, %edx\n&quot; ;__afl_area_ptr指向共享内存</span><br><span class="line">&quot;  testl %edx, %edx\n&quot;</span><br><span class="line">&quot;  je    __afl_setup\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>在<code>__afl_maybe_log</code>里面，会首先判断共享内存是否映射完成（我觉得这里也是在判断forkserver进程是否启动；__afl_area_ptr指向共享内存，在后面会解释），如果未完成映射，会执行<code>__afl_setup</code>；如果映射完成，那么会执行 <code>__afl_store</code>。</p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存主要用于AFL进程和target进程通信。target进程可以通过写入共享内存更新target的覆盖信息；而AFL进程可以在target执行完毕后，通过访问共享内存获取target的覆盖信息。</p>
<p>”共享内存“是Linux下进程间的一种通信方式，两个进程将各自的一段虚拟内存空间映射到同一块物理地址上，然后这两个进程就可以通过操作这块物理地址进行通信。Linux下共享内存的具体实现方式：<br>（1）使用shmget()函数创建共享内存，并返回一个共享内存标识符shm_id 。shmget()原型为<code> int shmget(key_t key, size_t size, int shmflg);</code>。但是创建完共享内存时，它还不能被任何进程访问<br>（2）shmat()函数的作用就是根据shm_id，将进程attach到共享内存上，即将进程虚拟地址空间中的一段内存映射到共享内存。shmat()的函数原型为<code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code>。</p>
<h3 id="AFL进程中共享内存设置"><a href="#AFL进程中共享内存设置" class="headerlink" title="AFL进程中共享内存设置"></a>AFL进程中共享内存设置</h3><p>AFL通过共享内存获取一个测试用例对目标程序的边覆盖信息。AFL开启后，会通过<code>setup_shm()</code>设置共享内存。<br>（1）首先通过shmget()创建大小为MAP_SIZE的共享内存：<code>shm_id = shmget(IPC_PRIVATE, MAP_SIZE, IPC_CREAT | IPC_EXCL | 0600); </code><br>（2）将共享内存标识符存储到环境变量，forkserver进程和target进程就可以通过环境变量访问共享内存标识符：<code>shm_str = alloc_printf(&quot;%d&quot;, shm_id);  setenv(SHM_ENV_VAR, shm_str, 1);</code><br>（3）AFL使用变量 <font color = 'red'>trace_bits</font> attach到共享内存：<code>trace_bits = shmat(shm_id, NULL, 0);</code>，然后AFL就可以通过trace_bits访问共享内存。在每次执行target之前，AFL会将<font color = 'red'>trace_bits</font> 清零。</p>
<h3 id="target进程共享内存设置"><a href="#target进程共享内存设置" class="headerlink" title="target进程共享内存设置"></a>target进程共享内存设置</h3><p>在<font color=red>__alf_maybe_log</font>中，如果共享内存未完成映射，就会执行<code>je __afl_setup</code>设置共享内存。<code>__afl_setup</code>的作用是获取AFL进程设置的共享内存标识符，并在target进程内attach上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_setup:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Do not retry setup if we had previous failures. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpb $0, __afl_setup_failure\n&quot;</span><br><span class="line">&quot;  jne  __afl_return\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Map SHM, jumping to __afl_setup_abort if something goes wrong.\n&quot;</span><br><span class="line">&quot;     We do not save FPU&#x2F;MMX&#x2F;SSE registers here, but hopefully, nobody\n&quot;</span><br><span class="line">&quot;     will notice this early in the game. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl %eax\n&quot; ;将eax寄存器压栈</span><br><span class="line">&quot;  pushl %ecx\n&quot; ;将ecx寄存器压栈</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $.AFL_SHM_ENV\n&quot; ;压入getenv的参数</span><br><span class="line">&quot;  call  getenv\n&quot; ;getenv(AFL_SHM_ENV)，返回值存储在eax寄存器</span><br><span class="line">&quot;  addl  $4, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  testl %eax, %eax\n&quot; ;判断环境变量AFL_SHM_ENV是否存在</span><br><span class="line">&quot;  je    __afl_setup_abort\n&quot; ;环境变量AFL_SHM_ENV不存在，共享内存映射失败</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl %eax\n&quot; ; eax &#x3D; getenv(AFL_SHM_ENV)</span><br><span class="line">&quot;  call  atoi\n&quot; ; eax &#x3D; atoi(getenv(AFL_SHM_ENV))</span><br><span class="line">&quot;  addl  $4, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $0          &#x2F;* shmat flags    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $0          &#x2F;* requested addr *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl %eax        &#x2F;* SHM ID         *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  shmat\n&quot; ; eax &#x3D; shmat(shm_id, 0, 0)</span><br><span class="line">&quot;  addl  $12, %esp\n&quot; </span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl $-1, %eax\n&quot;</span><br><span class="line">&quot;  je   __afl_setup_abort\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Store the address of the SHM region. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  movl %eax, __afl_area_ptr\n&quot;</span><br><span class="line">&quot;  movl %eax, %edx\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  popl %ecx\n&quot;</span><br><span class="line">&quot;  popl %eax\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>分析上述桩代码，其实主要作了以下几件事：<br>（1）通过环境变量获取共享内存标识符shm_id：getenv(AFL_SHM_ENV)<br>（2）通过shmat()函数，将共享内存地址存储到__afl_area_ptr：___afl_area_ptr = shmat(shm_id, 0, 0)</p>
<h2 id="forkserver"><a href="#forkserver" class="headerlink" title="forkserver"></a>forkserver</h2><p>forkserver主要是为了避免频繁调用execve()引起的开销。在完成了共享内存映射后，就会进入forkserver，执行<code>__afl_forkserver</code>。</p>
<p>首先，看一下forkserver进程是如何创建的。AFL通过<font color = 'red'>init_forkserver()</font>进行forkserver相关的初始化工作：</p>
<ol>
<li><p>创建状态管道和命令管道，用于AFL和forkserver进程之间的通信：int st_pipe[2], ctl_pipe[2]；</p>
<p>AFL通过写命令管道向forkserver发送命令，forkserver通过读命令管道接收AFL的发送的命令；forkserver通过写状态管道向AFL发送信息，AFL通过读状态管道接收forkserver发送的信息。</p>
</li>
<li><p>创建forkserver进程：forksrv_pid = fork(); 在forkserver进程中：</p>
<p>首先对状态管道和命令管道进行重定位：dup2(ctl_pipe[0], FORKSRV_FD) 和 dup2(st_pipe[1], FORKSRV_FD <strong>+</strong> 1）。</p>
<p>之后，forkserver进程执行execv(target_path, argv); forkserver调用了execv之后，会在target第一个基本块处执行插入的桩代码，调用<code>__afl_maybe_log</code>，然后跳到<code>__afl_setup</code>设置共享内存。共享内存设置完毕后，就进入了<code>__afl_forkserver</code>。</p>
</li>
</ol>
<p>接下来看一下<code>__afl_forkserver</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_forkserver:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Enter the fork server mode to avoid the overhead of execve() calls. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl %eax\n&quot;</span><br><span class="line">&quot;  pushl %ecx\n&quot;</span><br><span class="line">&quot;  pushl %edx\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Phone home and tell the parent that we&#39;re OK. (Note that signals with\n&quot;</span><br><span class="line">&quot;     no SA_RESTART will mess it up). If this fails, assume that the fd is\n&quot;</span><br><span class="line">&quot;     closed because we were execve()d from an instrumented binary, or because\n&quot; </span><br><span class="line">&quot;     the parent doesn&#39;t want to use the fork server. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $4          &#x2F;* length    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_temp &#x2F;* data      *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;  &#x2F;* file desc *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  write\n&quot; ; write(STRINGIFY((FORKSRV_FD + 1)), __afl_temp, 4)</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl  $4, %eax\n&quot;</span><br><span class="line">&quot;  jne   __afl_fork_resume\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>forkserver首先会向状态管道写端（即 FORKSRV_FD + 1）写入4字节的内容，告诉AFL“<font color = 'red'>我准备好fork了</font>”，而AFL进程也会通过读状态管道，判断forkserver进程是否创建成功：rlen = read(fsrv_st_fd, &amp;status, 4)。</p>
<p>forkserver创建成功后，就会进入<code>__afl_fork_wait_loop</code> ，forkserver会阻塞，直到读取命令管道成功：read(STRINGIFY(FORKSRV_FD), __afl_tmp, 4)，然后forkserver判断AFL是否发送了“<font color = 'red'>fork一个子进程</font>“的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_fork_wait_loop:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Wait for parent by reading from the pipe. Abort if read fails. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $4          &#x2F;* length    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_temp &#x2F;* data      *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;        &#x2F;* file desc *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  read\n&quot; ; read(STRINGIFY(FORKSRV_FD), __afl_tmp, 4)</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl  $4, %eax\n&quot;</span><br><span class="line">&quot;  jne   __afl_die\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Once woken up, create a clone of our process. This is an excellent use\n&quot;</span><br><span class="line">&quot;     case for syscall(__NR_clone, 0, CLONE_PARENT), but glibc boneheadedly\n&quot;</span><br><span class="line">&quot;     caches getpid() results and offers no way to update the value, breaking\n&quot;</span><br><span class="line">&quot;     abort(), raise(), and a bunch of other things :-( *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>当forkserver收到AFL创建一个子进程的命令后，就会调用fork()创建target进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;  call fork\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl $0, %eax\n&quot;</span><br><span class="line">&quot;  jl   __afl_die\n&quot;</span><br><span class="line">&quot;  je   __afl_fork_resume\n&quot;</span><br></pre></td></tr></table></figure>

<p>在target进程里面，会跳到<code>__afl_fork_resume</code>执行，关闭文件描述符，恢复target的正常执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_fork_resume:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* In child process: close fds, resume execution. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY(FORKSRV_FD) &quot;\n&quot;</span><br><span class="line">&quot;  call  close\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;\n&quot;</span><br><span class="line">&quot;  call  close\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  addl  $8, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  popl %edx\n&quot;</span><br><span class="line">&quot;  popl %ecx\n&quot;</span><br><span class="line">&quot;  popl %eax\n&quot;</span><br><span class="line">&quot;  jmp  __afl_store\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p>在forkserver进程里面，也就是在父进程里面，会将target进程的PID写入状态管道，然后等待target进程结束。target进程结束后，forkserver会再次向AFL说“<font color = 'red'>我准备好fork了</font>”，并继续执行<code> __afl_fork_wait_loop</code>，等待AFL发送“<font color = 'red'>fork一个子进程</font>“的命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&quot;  &#x2F;* In parent process: write PID to pipe, then wait for child. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  movl  %eax, __afl_fork_pid\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $4              &#x2F;* length    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_fork_pid &#x2F;* data      *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;      &#x2F;* file desc *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  write\n&quot;</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $0             &#x2F;* no flags  *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_temp    &#x2F;* status    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl __afl_fork_pid &#x2F;* PID       *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  waitpid\n&quot;</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  cmpl  $0, %eax\n&quot;</span><br><span class="line">&quot;  jle   __afl_die\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  &#x2F;* Relay wait status to pipe, then loop back. *&#x2F;\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  pushl $4          &#x2F;* length    *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $__afl_temp &#x2F;* data      *&#x2F;\n&quot;</span><br><span class="line">&quot;  pushl $&quot; STRINGIFY((FORKSRV_FD + 1)) &quot;  &#x2F;* file desc *&#x2F;\n&quot;</span><br><span class="line">&quot;  call  write\n&quot;</span><br><span class="line">&quot;  addl  $12, %esp\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  jmp __afl_fork_wait_loop\n&quot;</span><br></pre></td></tr></table></figure>

<h2 id="边覆盖记录"><a href="#边覆盖记录" class="headerlink" title="边覆盖记录"></a>边覆盖记录</h2><p>在<font color=red>__alf_maybe_log</font>中，如果共享内存完成了映射，就会执行<code>__afl_store</code>，在共享内存中更新边覆盖情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  &quot;__afl_store:\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">  &quot;  &#x2F;* Calculate and store hit for the code location specified in ecx. There\n&quot;</span><br><span class="line">  &quot;     is a double-XOR way of doing this without tainting another register,\n&quot;</span><br><span class="line">  &quot;     and we use it on 64-bit systems; but it&#39;s slower for 32-bit ones. *&#x2F;\n&quot;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">#ifndef COVERAGE_ONLY</span><br><span class="line">  &quot;  movl __afl_prev_loc, %edi\n&quot; ;将__alf_prev_loc的值存储到寄存器edi</span><br><span class="line">  &quot;  xorl %ecx, %edi\n&quot;	 ;将“__alf_prev_loc 异或 ecx”的值存储到edi寄存器中，相当于将边ID存储到了寄存器edi中</span><br><span class="line">  &quot;  shrl $1, %ecx\n&quot; ;将ecx的值右移1位，然后存储至ecx寄存器中</span><br><span class="line">  &quot;  movl %ecx, __afl_prev_loc\n&quot; ;将ecx寄存器的值存储到__afl_prev_loc中</span><br><span class="line">#else</span><br><span class="line">  &quot;  movl %ecx, %edi\n&quot;</span><br><span class="line">#endif &#x2F;* ^!COVERAGE_ONLY *&#x2F;</span><br><span class="line">  &quot;\n&quot;</span><br><span class="line">#ifdef SKIP_COUNTS</span><br><span class="line">  &quot;  orb  $1, (%edx, %edi, 1)\n&quot;</span><br><span class="line">#else</span><br><span class="line">  &quot;  incb (%edx, %edi, 1)\n&quot;</span><br><span class="line">#endif &#x2F;* ^SKIP_COUNTS *&#x2F;</span><br><span class="line">  &quot;\n&quot;</span><br></pre></td></tr></table></figure>

<p><code>__afl_store</code>的作用是计算前一个基本块（pre_location）到当前基本块（cur_location）这条边的ID，然后统计其出现次数。具体地，AFL使用（pre_location &gt;&gt; 1) xor (cur_locatino) 的方式记录一条边；使用共享内存（存储在寄存器edx中）统计边的出现次数。在上述汇编代码中：<br>（1）ecx存储的是<code>R(MAP_SIZE)</code>得到的值，也就是存储着为当前这个基本块分配的ID，即伪代码中的cur_location；<br>（2）<code>__afl_prev_loc</code>表示<font color = 'red'>上一个基本块的ID&gt;&gt;1</font>；<br>（3）edx存储的是共享内存的地址。<br>（4）<code>incb (%edx, %edi, 1)</code>这条指令就在共享内存（edx）中，将这条边（edi）的出现次数+1。</p>
<p>__afl_store之后是<code>__afl_return:\n</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;__afl_return:\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br><span class="line">&quot;  addb $127, %al\n&quot;</span><br><span class="line">&quot;  sahf\n&quot;</span><br><span class="line">&quot;  ret\n&quot;</span><br><span class="line">&quot;\n&quot;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>AFL进程创建了forkserver进程，forkserver进程根据AFL的指令创建target进程。</li>
<li>AFL和forkserver通过管道进行通信</li>
<li>AFL和target通过共享内存通信，获取目标程序代码覆盖信息。AFL通过trace_bits访问共享内存，target通过__afl_area_ptr访问共享内存</li>
<li>AFL使用边覆盖信息</li>
</ol>
<p><img src="/images/image-20210504232350375.png"></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/28/AFL%E6%A6%82%E8%BF%B0/" rel="prev" title="AFL概述">
      <i class="fa fa-chevron-left"></i> AFL概述
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E6%A1%A9"><span class="nav-number">1.</span> <span class="nav-text">插桩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">2.</span> <span class="nav-text">共享内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AFL%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">AFL进程中共享内存设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#target%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.2.</span> <span class="nav-text">target进程共享内存设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#forkserver"><span class="nav-number">3.</span> <span class="nav-text">forkserver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%B9%E8%A6%86%E7%9B%96%E8%AE%B0%E5%BD%95"><span class="nav-number">4.</span> <span class="nav-text">边覆盖记录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lxumei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lxumei</span>
</div>

<!--
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
